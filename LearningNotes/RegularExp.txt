爬虫

正则表达式：匹配字符串
用一种描述性的语言来给字符串定义一个规则，凡是符合规则的字符串，
们就认为它“匹配”了，否则，该字符串就是不合法的。

精确匹配：
\d 一个数字
eg: '123\d'  可以匹配'1234' 不能匹配'123a'

\w 一个字母或数字
eg: '123\w'  可以匹配'123a'  不能匹配'1234'

\s 一个空格或空白符

. 任意字符
eg: '123.' 可以匹配'1234'  '123a' '123!'

* 任意个字符
+ 至少一个字符
？ 0个或1个字符
{n} n个字符
{n,m} n-m个字符
eg:
\d{3}\s+\d{3,8}

1.\d{3}表示匹配3个数字，例如'010'；
2.\s可以匹配一个空格（也包括Tab等空白符），所以\s+表示至少有一个空格，例如匹配' '，' '等；
3.\d{3,8}表示3-8个数字，例如'1234567'。
综合起来，上面的正则表达式可以匹配以任意个空格隔开的带区号的电话号码。例如：010-123456

[] 表示范围
[0-9a-zA-Z\_] 一个数字、字母或者下划线
[0-9a-zA-Z\_]+  至少由一个数字、字母或者下划线组成的字符串
[a-zA-Z\_][0-9a-zA-Z\_]* 由字母或下划线开头，后接任意个由一个数字、字母或者下划线组成的字串
[a-zA-Z\_][0-9a-zA-Z\_]{0，19} 限制了变量的长度是1-20个字符（前面1个字符+后面最多19个字符）
A|B 匹配A或B
^ 行的开头
$ 行的结束

python里的re模块，包含所有正则表达式的功能
由于Python的字符串本身也用\转义
所以我们使用Python的r''前缀，就不用考虑转义的问题
s = r'ABC\-001'

判断正则表达式是否匹配
import re
expression = r'正则表达式'
test = '用户输入的字符串'
if re.match(expression, test):
	print('OK')
else
	print('FAILED')
	
用正则表达式切分字符串
re.split(expression, test)
#可以用正则表达式来把不规范的输入转化成正确的数组

用正则表达式分组，提取子串
如果正则表达式中定义了组，就可以在Match对象上用group()方法提取出串来。
group(0)永远是原始字符串，group(1)、group(2)……表示第1、2、……个子。
eg:
>>>m = re.match(r'^(\d{3})-(\d{3,8})$','010-12345')
>>>m.group(0)
'010-12345'
>>>m.group(1)
'010'
>>>m.group(2)
'12345'

预编译正则表达式
import re
re_expr = re.compile(r'Regular Expression')
re_expr.match('test')
re_exp.match('test').group()